configfile: "config/config.yml"

##################################################################
##                         Author Info                          ##
##################################################################

# Author: Kevin A. Boyd
# Email: kevinboyd76@gmail.com
# GitHub: https://github.com/kevinboyd76
# Date Created: May 27, 2025
# Last Modified: May 27, 2025
# Version: 1.0.0
#
# Description: This workflow processes SLAM-Seq data from raw FASTQ
# files to normalized signal tracks with spike-in and scale factor 
# correction.
# 
# Adapted from: SLAM-Seq Protocol from Rafal Donczew & John Ridenour

##################################################################
##                  Specific Steps in Pipeline                  ##
##################################################################

#  Steps:
#  1) FastQC / MultiQC (Raw Samples)
#  2) Process raw Fastq UMIs
#  3) Adapter Trim (BBDuk)
#  4) FastQC / MultiQC (Trimmed Samples)
#  5) Run slam dunk all
#  6) Run slam dunk count
#  7) Run alleyoop rates
#  8) Run alleyoop tccontext
#  9) Run alleyoop utrrates
# 10) Run alleyoop snpeval
# 11) Run alleyoop summary
# 12) Run alleyoop merge
# 13) Run alleyoop tcperreadpos
# 14) Run alleyoop dump
# 15) Run multiqc on slam dunk output


##################################################################
##                    Define input functions                    ##
##################################################################

import os
import pandas as pd

# load samples table and set samples naming
samples_df = pd.read_csv("config/samples.csv").set_index("sample", drop=False)
SAMPLES = samples_df.index.tolist()

# dictionary based input function
def fq_dict_from_sample(wildcards):
    """
    Return a dict: {"r1": <R1path>, "r2": <R2path>} for each sample.
    Use 'unpack(...)' in the rules so we can reference input.r1, input.r2.
    """
    row = samples_df.loc[wildcards.sample]
    return {
        "r1": row["fastq1"],
        "r2": row["fastq2"]
    }

# Extract unique merge groups from the new column (e.g. DMSO, IAA, etc.)
merge_groups = samples_df["merge_group"].unique().tolist()

# define begraphs input for average scale factor (CPM) tracks
def bedgraphs_for_group(wildcards):
    """
    Return a list of bedGraph files belonging to 'merge_group' == wildcards.group.
    """
    # Filter samples by group
    samples_in_group = [
        s for s in SAMPLES
        if samples_df.loc[s, "merge_group"] == wildcards.group
    ]
    # Build the bedGraph filenames for those samples
    return [
        f"results/bedgraph/cpm/{sample}_cpm.bg"
        for sample in samples_in_group
    ]

# define bedgraphs input for average spike in tracks
def spikein_bedgraphs_for_group(wildcards):
    """
    Return a list of spike-in normalized bedGraph files for the given merge_group.
    """
    samples_in_group = [
        s for s in SAMPLES
        if samples_df.loc[s, "merge_group"] == wildcards.group
    ]
    return [
        f"results/bedgraph/spikein/{sample}_spikein.bg"
        for sample in samples_in_group
    ]

##################################################################
##                          Rule All                            ##
##################################################################

rule all:
    input:
        # 1) FastQC / MultiQC reports for raw data
        expand("results/qc/fastqc/{sample}_R1_fastqc.html", sample=SAMPLES),
        expand("results/qc/fastqc/{sample}_R2_fastqc.html", sample=SAMPLES),
        "results/qc/multiqc/multiqc_report_raw.html",

        # 2) Processed UMIs from raw FASTQ files
        expand("results/fastp/{sample}_umi_R1.fastq.gz", sample=SAMPLES),
        expand("results/fastp/{sample}_umi_R2.fastq.gz", sample=SAMPLES),
        
        # 3) Trim Adapters in FASTQ files
        expand("results/trimmed/{sample}_R1_trimmed.fastq.gz", sample=SAMPLES),
        expand("results/trimmed/{sample}_R2_trimmed.fastq.gz", sample=SAMPLES),
        
        # FastQC / MultiQC reports for trimmed data
        expand("results/qc/fastqc/{sample}_R1_trimmed_fastqc.html", sample=SAMPLES),
        expand("results/qc/fastqc/{sample}_R2_trimmed_fastqc.html", sample=SAMPLES),
        "results/qc/multiqc/trimmed/multiqc_report_trimmed.html"


##################################################################
##                     Fastqc on Raw Fastqs                     ##
##################################################################

rule fastqc_raw:
    input:
        unpack(fq_dict_from_sample)
    output:
        html1="results/qc/fastqc/{sample}_R1_fastqc.html",
        zip1 ="results/qc/fastqc/{sample}_R1_fastqc.zip",
        html2="results/qc/fastqc/{sample}_R2_fastqc.html",
        zip2 ="results/qc/fastqc/{sample}_R2_fastqc.zip"
    envmodules:
        config["fastqc"]
    log:
        "results/logs/fastqc/{sample}.log"
    shell:
        """
        fastqc -o results/qc/fastqc {input.r1} {input.r2} 2> {log}

        dir="results/qc/fastqc"
        baseR1=$(basename {input.r1} .fastq.gz)
        mv $dir/${{baseR1}}_fastqc.html {output.html1} || true
        mv $dir/${{baseR1}}_fastqc.zip {output.zip1} || true

        baseR2=$(basename {input.r2} .fastq.gz)
        mv $dir/${{baseR2}}_fastqc.html {output.html2} || true
        mv $dir/${{baseR2}}_fastqc.zip {output.zip2} || true
        """


##################################################################
##                     Multiqc on Raw Fastqs                    ##
##################################################################

rule multiqc_raw:
    input:
        expand("results/qc/fastqc/{sample}_R1_fastqc.zip", sample=SAMPLES),
        expand("results/qc/fastqc/{sample}_R2_fastqc.zip", sample=SAMPLES)
    output:
        "results/qc/multiqc/multiqc_report_raw.html"
    envmodules:
        config["multiqc"]
    log:
        "results/logs/multiqc/multiqc_raw.log"
    shell:
        """
        multiqc results/qc/fastqc -o results/qc/multiqc 2> {log}
        """


##################################################################
##                    Process UMIs with Fastp                   ##
##################################################################

rule process_umis:
    input:
        unpack(fq_dict_from_sample)
    output:
        r1_umi="results/fastp/{sample}_umi_R1.fastq.gz",
        r2_umi="results/fastp/{sample}_umi_R2.fastq.gz"
    envmodules:
        config["fastp"]
    log:
        "results/logs/fastp/{sample}_umi.log"
    shell:
        """
        fastp --in1 {input.r1} \
            --in2 {input.r2} \
            --out1 {output.r1_umi} \
            --out2 {output.r2_umi} \
            --umi \
            --umi_loc read2 \
            --umi_len 12 \
            --disable_adapter_trimming \
            --disable_trim_poly_g \
            --disable_quality_filtering \
            --disable_length_filtering \
		    --json results/logs/fastp/${sample_name}_umi_fastp.json \
		    --html results/logs/fastp/${sample_name}_umi_fastp.html \
            2> {log}
        """


##################################################################
##                      Adapter Trimming                        ##
##################################################################

rule trim_adapters:
    input:
        unpack(fq_dict_from_sample)
    output:
        r1_trim="results/trimmed/{sample}_R1_trimmed.fastq.gz",
        r2_trim="results/trimmed/{sample}_R2_trimmed.fastq.gz"
    params:
        bbmap_ref=config["bbmap_ref"]
    envmodules:
        config["bbmap"]
    log:
        "results/logs/trim/{sample}.log"
    shell:
        """
        bbduk.sh \
            in1={input.r1} \
            in2={input.r2} \
            out1={output.r1_trim} \
            out2={output.r2_trim} \
            ref={params.bbmap_ref} \
            trimpolyg=12 \
    		trimpolya=12 \
    		k=13 \
    		ktrim=r \
    		mink=5 \
    		qtrim=r \
    		trimq=10 \
    		minlength=20 \
            2> {log}
        """


##################################################################
##                   Fastqc on Trimmed Fastqs                   ##
##################################################################

rule fastqc_trimmed:
    input:
        r1_trim="results/trimmed/{sample}_R1_trimmed.fastq.gz",
        r2_trim="results/trimmed/{sample}_R2_trimmed.fastq.gz"
    output:
        html1="results/qc/fastqc/{sample}_R1_fastqc.html",
        zip1 ="results/qc/fastqc/{sample}_R1_fastqc.zip",
        html2="results/qc/fastqc/{sample}_R2_fastqc.html",
        zip2 ="results/qc/fastqc/{sample}_R2_fastqc.zip"
    envmodules:
        config["fastqc"]
    log:
        "results/logs/fastqc/{sample}.log"
    shell:
        """
        fastqc -o results/qc/fastqc {input.r1} {input.r2} 2> {log}

        dir="results/qc/fastqc/trimmed"
        baseR1=$(basename {input.r1} .fastq.gz)
        mv $dir/${{baseR1}}_fastqc.html {output.html1} || true
        mv $dir/${{baseR1}}_fastqc.zip {output.zip1} || true

        baseR2=$(basename {input.r2} .fastq.gz)
        mv $dir/${{baseR2}}_fastqc.html {output.html2} || true
        mv $dir/${{baseR2}}_fastqc.zip {output.zip2} || true
        """


##################################################################
##                   Multiqc on Trimmed Fastqs                  ##
##################################################################

rule multiqc_trimmed:
    input:
        expand("results/qc/fastqc/trimmed/{sample}_R1_fastqc.zip", sample=SAMPLES),
        expand("results/qc/fastqc/trimmed/{sample}_R2_fastqc.zip", sample=SAMPLES)
    output:
        "results/qc/multiqc/trimmed/multiqc_report_trimmed.html"
    envmodules:
        config["multiqc"]
    log:
        "results/logs/multiqc/multiqc_trimmed.log"
    shell:
        """
        multiqc results/qc/fastqc -o results/qc/multiqc 2> {log}
        """


##################################################################
##                           Slam Dunk                          ##
##################################################################

